inherit_from: experiments/config_default.yaml
VERBOSE: true
name: '3DSSG_test_5'
GPU: [0]
training:
 batch: 1
 data_workers: 2
 lr: 1e-3
 patient: 15
 optimizer: 'adamw'
 amsgrad: true
 lambda_mode: constant # [constant, dynamic]. dynamic will calculate the ratio of the number of node and edge.
 lambda_node: 0.1 # learning rate ratio
 lambda_edge: 1.0 # learning rate ratio
 scheduler:
  method: reduceluronplateau # [none, multisteplr, reduceluronplateau]
  milestones: [750, 1000]
  gamma: 0.5
  factor: 0.1
  args: {
    "mode":"max", 
    "verbose": true,
  }
 out_dir: experiments/
 model_selection_metric: iou_node_cls
 model_selection_mode: maximize # can be maximize or minimize. e.g. if it's "loss", should "minimize", if it's accuracy, should "maximize"
 max_epoch: 100
model:
 method: sgpn
 multi_rel: true # multiple relationship 
 use_rgb: false
 use_normal: false
 img_feature_dim: 256
 num_points_union: 512 # for 3DSSG
 node_feature_dim: 256
 edge_feature_dim: 256
 edge_descriptor_dim: 8
 gnn:
  method: triplet # [none, fan, triplet]
  hidden_dim: 256
  num_layers: 5
  num_heads: 0
  drop_out: 0
data:
 input_type: sgpn #[3RScan, graph, sgfn, sgpn]
 path: "./data/3RScan_3RScan160/"
 label_file: "labels.instances.align.annotated.v2.ply"
 sample_in_runtime: true
 sample_num_nn: 1
 sample_num_seed: 1
 drop_edge: 0 # if is int and >0, select given number. if is float/double, select percentage between [1-x,1]
 drop_edge_eval: 0 # if is int and >0, select given number. if is float/double, select percentage between [1-x,1]
 normalize_weight: true 
 max_num_edge: -1 # maximum number of edges for training (to save memory)
 full_edge: true # connect all selected nodes
logging:
 method: wandb # [tensorboard, wandb, none]
 log_grad_freq: 1000 
 log_graph: True
wandb:
 dry_run: false
 entity: 'shunchengwu'
 project: "ssg"
 tags: ["ssg", "3dssg"]
 dir: logs/
